<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gradient Calculator - Fully Local HTML</title>
  <style>
    :root{
      --bg-start: #6a11cb;
      --bg-mid: #2575fc;
      --bg-end: #00d0ff;
      --card: rgba(255,255,255,0.22);
      --card-strong: rgba(255,255,255,0.28);
      --text: #0b1020;
      --text-light: #e8f0ff;
      --shadow: rgba(0,0,0,.25);
    }

    /* Animated gradient background for modern look */
    html, body {
      height: 100%;
    }
    body {
      margin: 0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto;
      color: #0b1020;
      /* Gradient background with smooth animation */
      background: linear-gradient(135deg, var(--bg-start) 0%, var(--bg-mid) 50%, var(--bg-end) 100%);
      background-size: 300% 300%;
      animation: gradientBG 18s ease infinite;
      display: grid;
      place-items: center;
      padding: 2rem;
    }

    @keyframes gradientBG {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* Calculator card (glassy) */
    .calculator {
      width: min(520px, 94vw);
      border-radius: 20px;
      padding: 18px;
      background: linear-gradient(135deg, rgba(255,255,255,.28), rgba(255,255,255,.18));
      border: 1px solid rgba(255,255,255,.6);
      box-shadow: 0 20px 50px rgba(0,0,0,.25);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    /* Display area (two lines: expression and optional result) */
    .display {
      display: grid;
      grid-template-columns: 1fr;
      align-items: end;
      min-height: 110px;
      padding: 14px 16px;
      border-radius: 14px;
      margin-bottom: 14px;
      background: linear-gradient(135deg, rgba(255,255,255,.9), rgba(255,255,255,.65));
      color: #0b0f1a;
      position: relative;
      overflow: hidden;
    }

    .display::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient( circle at 20% -20%, rgba(0,0,0,.08), transparent 40%);
      pointer-events: none;
      mix-blend-mode: multiply;
    }

    .expression {
      font-size: clamp(28px, 6vw, 46px);
      font-weight: 600;
      text-align: right;
      letter-spacing: .5px;
      padding: 6px 6px 2px 6px;
      word-break: break-word;
    }

    .hint {
      text-align: right;
      font-size: 12px;
      color: rgba(0,0,0,.5);
      padding: 0 6px 6px;
    }

    /* Button grid */
    .grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-gap: 12px;
    }

    .btn {
      border: none;
      border-radius: 12px;
      padding: 16px;
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      color: #1d1f2a;
      background: linear-gradient(#f9f9fb, #e9eefc);
      box-shadow: inset 0 1px #fff, 0 6px 12px rgba(0,0,0,.08);
      transition: transform .05s ease, box-shadow .2s ease;
      user-select: none;
    }

    .btn:hover { transform: translateY(-1px); }
    .btn:active { transform: scale(0.98); }

    /* Operators have a distinct look */
    .btn.operator {
      background: linear-gradient(135deg, #ffd166, #f4a261);
      color: #2b1e12;
    }

    /* Clear / Delete special styles */
    .btn.wide { grid-column: span 2; }
    .btn.accent { background: linear-gradient(135deg, #9b8dff, #6c5ce7); color: white; }

    /* Small screens adjust spacing nicely */
    @media (max-width: 420px) {
      .calculator { padding: 12px; }
      .btn { padding: 14px; font-size: 16px; }
    }

    /* Accessibility tweaks for reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .btn { transition: none; }
      @keyframes gradientBG { from { background-position: 0% 0%; } to { background-position: 100% 100%; } }
    }
  </style>
</head>
<body>
  <div class="calculator" aria-label="Beautiful gradient calculator">
    <div class="display" aria-label="Display area">
      <div id="expression" class="expression" aria-live="polite">0</div>
      <div id="screenHint" class="hint" style="position:absolute; right:12px; bottom:6px;"></div>
    </div>

    <div class="grid" role="grid" aria-label="Calculator keypad">
      <!-- Top row: Clear, Delete, Divide -->
      <button class="btn wide" data-action="clear" aria-label="Clear">C</button>
      <button class="btn" data-action="delete" aria-label="Delete">DEL</button>
      <button class="btn operator" data-value="/" aria-label="Divide">/</button>

      <!-- Row 2 -->
      <button class="btn" data-value="7" aria-label="7">7</button>
      <button class="btn" data-value="8" aria-label="8">8</button>
      <button class="btn" data-value="9" aria-label="9">9</button>
      <button class="btn operator" data-value="*" aria-label="Multiply">*</button>

      <!-- Row 3 -->
      <button class="btn" data-value="4" aria-label="4">4</button>
      <button class="btn" data-value="5" aria-label="5">5</button>
      <button class="btn" data-value="6" aria-label="6">6</button>
      <button class="btn operator" data-value="-" aria-label="Minus">-</button>

      <!-- Row 4 -->
      <button class="btn" data-value="1" aria-label="1">1</button>
      <button class="btn" data-value="2" aria-label="2">2</button>
      <button class="btn" data-value="3" aria-label="3">3</button>
      <button class="btn operator" data-value="+" aria-label="Plus">+</button>

      <!-- Row 5: 0, ., = (0 spans two columns) -->
      <button class="btn wide" data-value="0" aria-label="0">0</button>
      <button class="btn" data-value="." aria-label="Decimal">.</button>
      <button class="btn" data-value="=" aria-label="Equals" style="grid-column: 4 / span 1;">=</button>
    </div>
  </div>

  <script>
    // Fully self-contained calculator logic with keyboard support and a nice UI.
    (function(){
      const exprEl = document.getElementById('expression');
      const hintEl = document.getElementById('screenHint');

      let expression = ''; // current input/expression
      let justEvaluated = false; // if last action was evaluation

      function updateDisplay() {
        // Show 0 when empty
        const toShow = expression.length ? expression : '0';
        exprEl.textContent = toShow;
      }

      // Utility: get last number token (after last operator)
      function getLastNumber() {
        const parts = expression.split(/[\+\-\*\/]/);
        return parts.length ? parts[parts.length - 1] : '';
      }

      // Clean and format result
      function trimResult(n) {
        if (!isFinite(n)) return 'Error';
        if (Number.isInteger(n)) return String(n);
        // Limit precision to avoid long tails
        let str = n.toFixed(12);
        str = str.replace(/\.?0+$/, '');
        return str;
      }

      // Safe evaluator: supports +, -, *, / and unary minus
      function evaluateExpression(input) {
        const s = input.replace(/\s+/g, '');
        if (s.length === 0) return '';
        // If ends with operator, ignore evaluate
        if (/[+\-*/]$/.test(s)) return 'Error';

        // Tokenize with support for unary minus
        const tokens = [];
        let i = 0;
        let prevWasOp = true; // at start unary minus allowed
        while (i < s.length) {
          const c = s[i];
          if (/[0-9.]/.test(c)) {
            let j = i;
            while (j < s.length && /[0-9.]/.test(s[j])) j++;
            const num = s.slice(i, j);
            if (!/^(\d+|\d*\.\d+|\.\d+)$/.test(num)) return 'Error';
            tokens.push({ type: 'num', value: parseFloat(num) });
            i = j;
            prevWasOp = false;
          } else if (c === '+'
                 || c === '*'
                 || c === '/') {
            tokens.push({ type: 'op', value: c });
            i++;
            prevWasOp = true;
          } else if (c === '-') {
            if (prevWasOp) {
              // unary minus for next number
              i++;
              let j = i;
              while (j < s.length && /[0-9.]/.test(s[j])) j++;
              const num = s.slice(i, j);
              if (!/^(\d+|\d*\.\d+|\.\d+)$/.test(num)) return 'Error';
              tokens.push({ type: 'num', value: -parseFloat(num) });
              i = j;
              prevWasOp = false;
            } else {
              tokens.push({ type: 'op', value: '-' });
              i++;
              prevWasOp = true;
            }
          } else {
            return 'Error';
          }
        }

        // Shunting-yard to RPN
        const output = [];
        const opStack = [];
        const prec = { '+': 1, '-': 1, '*': 2, '/': 2 };
        for (const t of tokens) {
          if (t.type === 'num') {
            output.push(t.value);
          } else if (t.type === 'op') {
            while (opStack.length && opStack[opStack.length - 1] !== '(' &&
                   prec[opStack[opStack.length - 1]] >= prec[t.value]) {
              output.push(opStack.pop());
            }
            opStack.push(t.value);
          }
        }
        while (opStack.length) output.push(opStack.pop());

        // RPN evaluation
        const st = [];
        for (const item of output) {
          if (typeof item === 'number') {
            st.push(item);
          } else {
            const b = st.pop();
            const a = st.pop();
            if (typeof a !== 'number' || typeof b !== 'number') return 'Error';
            let val;
            switch (item) {
              case '+': val = a + b; break;
              case '-': val = a - b; break;
              case '*': val = a * b; break;
              case '/': val = a / b; break;
            }
            if (!isFinite(val)) return 'Error';
            st.push(val);
          }
        }
        if (st.length !== 1) return 'Error';
        return st[0];
      }

      // Button interactions
      const grid = document.querySelector('.grid');
      grid.addEventListener('click', (e) => {
        const btn = e.target.closest('.btn');
        if (!btn) return;
        const value = btn.dataset.value;
        const action = btn.dataset.action;

        if (action === 'clear') {
          expression = '';
          justEvaluated = false;
          updateDisplay();
          hintEl.textContent = '';
          return;
        }
        if (action === 'delete') {
          if (expression.length > 0) {
            expression = expression.slice(0, -1);
            updateDisplay();
          }
          hintEl.textContent = '';
          return;
        }

        // Regular value input (digits, dot, or operator)
        if (value !== undefined) {
          // If previously evaluated and user starts typing a digit, start fresh
          if (justEvaluated) {
            if (/[0-9.]/.test(value)) {
              expression = '';
              justEvaluated = false;
            }
          }

          // If dot entered, ensure not more than one in current number
          if (value === '.') {
            const lastNum = getLastNumber();
            if (lastNum.includes('.')) {
              hintEl.textContent = 'Each number can have only one decimal point';
              return;
            }
          }

          // If last character is a closing or opening issue, we simply append
          expression += value;
          // Clear any previous hint
          hintEl.textContent = '';
          // Update display
          updateDisplay();
          return;
        }
      });

      // Keyboard support
      document.addEventListener('keydown', (ev) => {
        const key = ev.key;

        if (/^[0-9]$/.test(key) || key === '.') {
          ev.preventDefault();
          appendValue(key);
          return;
        }
        if (['+', '-', '*', '/'].includes(key)) {
          ev.preventDefault();
          appendValue(key);
          return;
        }
        if (key === 'Enter' || key === '=') {
          ev.preventDefault();
          performEvaluate();
          return;
        }
        if (key === 'Backspace') {
          ev.preventDefault();
          if (expression.length > 0) {
            expression = expression.slice(0, -1);
            updateDisplay();
          }
          return;
        }
        if (key === 'Escape' || key.toLowerCase() === 'c') {
          ev.preventDefault();
          expression = '';
          justEvaluated = false;
          updateDisplay();
          hintEl.textContent = '';
          return;
        }
      });

      function appendValue(val) {
        // Reset after evaluation when user starts new input with a digit
        if (justEvaluated) {
          expression = '';
          justEvaluated = false;
        }

        if (val === '.') {
          const last = getLastNumber();
          if (last.includes('.')) return;
        }

        expression += val;
        updateDisplay();
      }

      function getLastNumber() {
        const parts = expression.split(/[\+\-\*\/]/);
        return (parts.length ? parts[parts.length - 1] : '');
      }

      function performEvaluate() {
        if (!expression) return;
        // Only evaluate if ends with a number (not an operator)
        if (/[+\-*/]$/.test(expression.trim())) {
          hintEl.textContent = 'Expression ends with an operator';
          return;
        }
        const result = evaluateExpression(expression);
        if (result === 'Error') {
          expression = 'Error';
          updateDisplay();
          justEvaluated = true;
          hintEl.textContent = 'Invalid expression';
          return;
        }
        const formatted = trimResult(result);
        expression = formatted;
        updateDisplay();
        justEvaluated = true;
        hintEl.textContent = '';
      }

      // Initialize display
      updateDisplay();
    })();
  </script>
</body>
</html>